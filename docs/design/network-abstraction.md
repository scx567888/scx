# 通讯抽象模型

## 1. 统一性：连续性的存在

### 🌟 一切通信皆源于「连续性的存在」

从本质的角度出发，通信世界中的所有交互，都可以视为一种 **连续性的存在** 。无论是 TCP 连接与数据传输，HTTP 请求与响应，还是
WebSocket 消息，它们本质上都是一种 **持续性的信息交互过程**。  
这一过程是动态的、连续的，但在不同场景中可以通过不同的抽象层次来进行分析与建模。

---

## 2. 抽象视角：事件与流

我们选择从不同的角度去看待这种连续的存在，并将其抽象为 **事件** 和 **流** ，这两个不同的概念代表了不同的设计抽象：

- **事件** ：代表不确定的、瞬时的触发点。事件发生的时刻是随机的、不可预测的，我们只能在事件发生后进行响应。事件本质上是“信息流的切分点”。
- **流** ：代表持续的、可控的传输过程。流是一个连续的行为，表示信息或数据的长期、连续的交互。流可以主动控制，随时读取或写入数据。

| 类型            | 定义         | 特征        | 示例                            |
|---------------|------------|-----------|-------------------------------|
| **事件（Event）** | 瞬时发生的离散动作  | 不可预测、不可持续 | TCP 连接建立、HTTP 请求到达            |
| **流（Stream）** | 可持续消费的数据序列 | 有起点、可控读取  | TCP 数据内容、HTTP 请求体、WebSocket 帧 |

> ✨ 事件是点，流是线。

---

## 3. 事件与流的相互关系

事件与流并非对立，而是同一事物在不同抽象层次的表达：

通过区分这两个概念，将它们应用到网络协议的处理流程中，分别处理那些不确定、瞬时的行为（事件）和持续的数据流动（流)

---

## 4. 消费方式的差异：Push vs Pull

| 机制     | 触发方式    | 编程模式         |
|--------|---------|--------------|
| **事件** | 系统主动推送  | 回调（callback） |
| **流**  | 使用者主动拉取 | 读取（read）接口   |

### 示例对照

| 场景               | 类型 | 接口                      |
|------------------|----|-------------------------|
| 新的 TCP 连接建立      | 事件 | `onConnect(handler)`    |
| 接收 TCP 数据        | 流  | `socket.read()`         |
| 新的 HTTP 请求到达     | 事件 | `onRequest(handler)`    |
| 接收 WebSocket 数据帧 | 流  | `websocket.readFrame()` |

> ✅ 无论是 TCP、HTTP 还是 WebSocket，框架中所有通讯相关模块都将遵循该统一抽象，确保全框架设计具备**一致性, 可组合性, 可预见性**。

---
