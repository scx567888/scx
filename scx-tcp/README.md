# SCX TCP 设计思路

## 1. 统一性：连续性的存在

### 🌟 一切通信皆源于「连续性的存在」

从本质的角度出发，通信世界中的所有交互，都可以视为一种 **连续性的存在** 。无论是 TCP 连接与数据传输，HTTP 请求与响应，还是
WebSocket 消息，它们本质上都是一种 **持续性的信息交互过程**。  
这一过程是动态的、连续的，但在不同场景中可以通过不同的抽象层次来进行分析与建模。

---

## 2. 抽象视角：事件与流

我们选择从不同的角度去看待这种连续的存在，并将其抽象为 **事件** 和 **流** ，这两个不同的概念代表了不同的设计抽象：

- **事件** ：代表不确定的、瞬时的触发点。事件发生的时刻是随机的、不可预测的，我们只能在事件发生后进行响应。事件本质上是“信息流的切分点”。
- **流** ：代表持续的、可控的传输过程。流是一个连续的行为，表示信息或数据的长期、连续的交互。流可以主动控制，随时读取或写入数据。

| 类型            | 定义         | 特征        | 示例                            |
|---------------|------------|-----------|-------------------------------|
| **事件（Event）** | 瞬时发生的离散动作  | 不可预测、不可持续 | TCP 连接建立、HTTP 请求到达            |
| **流（Stream）** | 可持续消费的数据序列 | 有起点、可控读取  | TCP 数据内容、HTTP 请求体、WebSocket 帧 |

> ✨ 事件是点，流是线。

---

## 3. 事件与流的相互关系

事件与流并非对立，而是同一事物在不同抽象层次的表达：

通过区分这两个概念，将它们应用到网络协议的处理流程中，分别处理那些不确定、瞬时的行为（事件）和持续的数据流动（流)

---

## 4. 消费方式的差异：Push vs Pull

| 机制     | 触发方式    | 编程模式         |
|--------|---------|--------------|
| **事件** | 系统主动推送  | 回调（callback） |
| **流**  | 使用者主动拉取 | 读取（read）接口   |

### 示例对照

| 场景               | 类型 | 接口                      |
|------------------|----|-------------------------|
| 新的 TCP 连接建立      | 事件 | `onConnect(handler)`    |
| 接收 TCP 数据        | 流  | `socket.read()`         |
| 新的 HTTP 请求到达     | 事件 | `onRequest(handler)`    |
| 接收 WebSocket 数据帧 | 流  | `websocket.readFrame()` |

> ✅ 无论是 TCP、HTTP 还是 WebSocket，未来所有协议都将遵循该统一抽象，确保全框架设计具备**一致性与可组合性**。

---

## 5. 配置类型：通信系统的语义构成单位

在设计中，**配置是一种宏观的语义概念**，用于表达通信系统中各类可设定行为。我们将其划分为三类，每类配置对应不同的生命周期与职责。

### 📚 三类配置

| 配置类型       | 含义与职责            | 生命周期        | 示例                                |
|------------|------------------|-------------|-----------------------------------|
| **主体配置**   | 定义客户端或服务器本体的长期特性 | 与通信对象生命周期一致 | `tls`、`backlog`                   |
| **连接行为配置** | 控制连接建立过程的短时策略    | 仅在连接阶段存在    | `timeout`、`bindPort`、`remoteAddr` |
| **事件注册配置** | 描述连接建立后对事件的响应策略  | 与连接生命周期一致   | `onConnect(handler)`、`onClose()`  |

### 🧩 为何显式分类？

> 尽管**这三类配置可以通过构造函数、类方法或 setter 设置**，我们依然选择在语义上进行显式划分，原因在于：

- **突出各配置类型的职责边界与生命周期差异**；
- **提升使用者的理解能力与使用意图的清晰表达**；
- **遵循接口一致性与纯粹性设计原则**。

这不是实现上的限制，而是设计层次上的选择。

---

### 📦 对应的传递方式（设计约定）

| 配置类型   | 默认传递方式                     | 说明                                        |
|--------|----------------------------|-------------------------------------------|
| 主体配置   | 构造参数 / Setter              | 生命周期长、可动态修改，通常通过 `options()` 获取和设置        |
| 连接行为配置 | `start()` / `connect()` 参数 | 仅在连接建立阶段传递，随后即失效                          |
| 事件注册配置 | 独立方法注册                     | 虽为“配置”，但为了突出其语义，采用显式注册形式（如 `onConnect()`） |

---

## ✅ 使用示例

```java
public static void serverDemo() {

    // 通信主体持有配置
    var server = new TCPServer(new TCPServerOptions().tls(TLS.ofDefault()));

    // 可随时动态修改配置
    server.options().tls(TLS.ofTrustAny());

    // 事件注册配置
    server.onConnect(connect -> {
        System.out.println(connect.remoteAddress());
    });

    // 连接行为配置
    server.start(8899);
}

public static void clientDemo() {

    // 通信主体持有配置
    var client = new TCPClient(new TCPClientOptions().tls(TLS.ofDefault()));

    // 可随时动态修改配置
    client.options().tls(TLS.ofTrustAny());

    // client 不支持事件注册

    // 连接行为配置
    client.connect(new InetSocketAddress("127.0.0.1", 8899), 5000);
}
```
