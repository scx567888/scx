# SCX TCP 框架设计思路

## 1. 统一性：连续性的存在

### 🌟 一切通信皆源于「连续性的存在」

从最基础的哲学角度来看，通信世界中的所有交互都可以被视为某种“可重复发生的连续存在”。  
不论是 TCP 连接与数据传输，HTTP 请求与响应，还是 WebSocket 消息，它们本质上都是一种持续的信息交换过程。  
这个过程是动态的、连续的，可以从不同抽象层次进行划分与理解。

---

## 2. 抽象视角：事件与流

我们从两个核心视角来理解这种连续性：**事件** 与 **流**。

### ✴️ 事件 vs 流

| 类型            | 定义         | 特征        | 示例                            |
|---------------|------------|-----------|-------------------------------|
| **事件（Event）** | 瞬时发生的离散动作  | 不可预测、不可持续 | TCP 连接建立、HTTP 请求到达            |
| **流（Stream）** | 可持续消费的数据序列 | 有起点、可控制读取 | TCP 数据内容、HTTP 请求体、WebSocket 帧 |

- **事件**：代表某一瞬间的不确定触发点，是信息流的“切分点”，只可响应，无法预测。
- **流**：代表可控的、持续的信息传输，可按需主动读取，是“连续性存在”的本体。

> ✨ 事件是点，流是线。

---

## 3. 事件与流的相互关系

事件与流并非对立，而是同一事物的两个抽象层级：

- **事件是流的切分点**，用于表达某一瞬时行为的边界；
- **流是事件的展开体**，代表持续的数据传输过程；
- 两者可相互转化，视语义而定。

在 SCX 的设计中，清晰地区分事件与流，有助于明确责任边界、保持设计纯洁性并增强开发者的理解力。

---

## 4. 消费方式上的差异：Push vs Pull

| 机制     | 描述      | 行为模式         |
|--------|---------|--------------|
| **事件** | 系统主动推送  | 回调（callback） |
| **流**  | 使用者主动拉取 | 读取（read）接口   |

### 示例对照

| 场景             | 类型 | 接口                      |
|----------------|----|-------------------------|
| 新的 TCP 连接建立    | 事件 | `onConnect(handler)`    |
| 接收 TCP 数据      | 流  | `socket.read()`         |
| 新的 HTTP 请求建立   | 事件 | `onRequest(handler)`    |
| 接收 WebSocket 帧 | 流  | `websocket.readFrame()` |

> ✅ 未来所有通信协议（TCP/HTTP/WebSocket）皆遵循此设计思想，确保全框架设计的**一致性与可组合性**。

---

## 5. 配置类型：通信系统的语义构成单位

在 SCX 中，**“配置”是一种宏观的设计概念**，用于描述通信系统中影响行为的各类可设定项。我们将其划分为三类，每类都有其独特的语义职责和生命周期。

| 配置类型         | 含义与职责                | 生命周期      | 示例                                |
|--------------|----------------------|-----------|-----------------------------------|
| **通信主体持有配置** | 定义客户端或服务器本体的特性       | 与对象生命周期一致 | `tls`、`backlog`                   |
| **连接行为配置**   | 用于建立连接时的行为策略，仅用于连接过程 | 短暂（连接阶段）  | `timeout`、`bindPort`、`remoteAddr` |
| **事件注册配置**   | 定义连接建立后如何响应特定事件      | 与连接共存     | `onConnect(handler)`、`onClose()`  |

### 🧩 为什么需要分类？

> 虽然**在实现上这三类配置都可以通过构造函数、类方法或 setter 设置**，我们仍选择在设计中进行显式区分，其目的在于：

- **清晰表达配置的语义责任与作用范围**；
- **增强使用者的理解力与预测性**；
- **维持接口结构的简洁、纯粹与一致性**。

这不是技术上的强制，而是出于对设计哲学的尊重。

### 📦 对应传递方式（设计约定）

| 配置类型     | 默认传递方式                     | 说明                                          |
|----------|----------------------------|---------------------------------------------|
| 通信主体持有配置 | 构造参数 / Setter              | 生命周期长、可动态修改，通常通过 `options()` 获取和设置          |
| 连接行为配置   | `start()` / `connect()` 参数 | 仅在连接建立过程中传递，之后即失效                           |
| 事件注册配置   | 独立方法注册                     | 虽可视为“配置”，但为突出其语义，采用显式事件注册方法，如 `onConnect()` |

---

### ✅ 实例说明：

```java
public static void serverDemo() {

    // 通信主体持有配置
    var server = new TCPServer(new TCPServerOptions().tls(TLS.ofDefault()));

    // 可以随时修改
    server.options().tls(TLS.ofTrustAny());

    // 事件注册配置
    server.onConnect(connect -> {
        System.out.println(connect.remoteAddress());
    });

    // 连接行为配置
    server.start(8899);
}

public static void clientDemo() {

    // 通信主体持有配置
    var client = new TCPClient(new TCPClientOptions().tls(TLS.ofDefault()));

    // 可以随时修改
    client.options().tls(TLS.ofTrustAny());

    // client 没有事件注册

    // 连接行为配置
    client.connect(new InetSocketAddress("127.0.0.1", 8899), 5000);
}
```

---

## 🧠 结语

SCX 的设计并不依赖主流共识，而是以哲学抽象为基础，构建出一致、纯粹、可验证、可组合的通信模型。  
所有的概念都源自于对“连续性存在”的理解，并在事件与流的统一视角下进行组织和实现。

> 如果你欣赏逻辑的力量、抽象的简洁、接口的一致性，那么 SCX 会是你值得信赖的通信基础设施。

---
